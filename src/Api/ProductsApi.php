<?php
/**
 * ProductsApi
 * PHP version 8.1
 *
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Voucherify API
 *
 * Voucherify promotion engine REST API. Please see https://docs.voucherify.io/docs for more details.
 *
 * The version of the OpenAPI document: v2018-08-01
 * Contact: support@voucherify.io
 * @generated Generated by: https://openapi-generator.tech
 * Generator version: 7.7.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use InvalidArgumentException;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\Promise\PromiseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * ProductsApi Class Doc Comment
 *
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ProductsApi
{
    /**
     * @var ClientInterface
     */
    protected ClientInterface $client;

    /**
     * @var Configuration
     */
    protected Configuration $config;

    /**
     * @var HeaderSelector
     */
    protected HeaderSelector $headerSelector;

    /**
     * @var int Host index
     */
    protected int $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createProduct' => [
            'application/json',
        ],
        'createSku' => [
            'application/json',
        ],
        'deleteProduct' => [
            'application/json',
        ],
        'deleteSku' => [
            'application/json',
        ],
        'getProduct' => [
            'application/json',
        ],
        'getSku' => [
            'application/json',
        ],
        'importProductsUsingCsv' => [
            'multipart/form-data',
        ],
        'importSkusUsingCsv' => [
            'multipart/form-data',
        ],
        'listProducts' => [
            'application/json',
        ],
        'listSkusInProduct' => [
            'application/json',
        ],
        'updateProduct' => [
            'application/json',
        ],
        'updateProductsInBulk' => [
            'application/json',
        ],
        'updateProductsMetadataInBulk' => [
            'application/json',
        ],
        'updateSku' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface|null $client
     * @param Configuration|null   $config
     * @param HeaderSelector|null  $selector
     * @param int                  $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * Operation createProduct
     *
     * Create Product
     *
     * @param  \OpenAPI\Client\Model\ProductsCreateRequestBody|null $products_create_request_body Specify the product parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createProduct'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductsCreateResponseBody
     */
    public function createProduct(
        ?\OpenAPI\Client\Model\ProductsCreateRequestBody $products_create_request_body = null,
        string $contentType = self::contentTypes['createProduct'][0]
    ): \OpenAPI\Client\Model\ProductsCreateResponseBody
    {
        list($response) = $this->createProductWithHttpInfo($products_create_request_body, $contentType);
        return $response;
    }

    /**
     * Operation createProductWithHttpInfo
     *
     * Create Product
     *
     * @param  \OpenAPI\Client\Model\ProductsCreateRequestBody|null $products_create_request_body Specify the product parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createProduct'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductsCreateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function createProductWithHttpInfo(
        ?\OpenAPI\Client\Model\ProductsCreateRequestBody $products_create_request_body = null,
        string $contentType = self::contentTypes['createProduct'][0]
    ): array
    {
        $request = $this->createProductRequest($products_create_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\OpenAPI\Client\Model\ProductsCreateResponseBody', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductsCreateResponseBody' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductsCreateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProductsCreateResponseBody';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductsCreateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createProductAsync
     *
     * Create Product
     *
     * @param  \OpenAPI\Client\Model\ProductsCreateRequestBody|null $products_create_request_body Specify the product parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createProduct'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createProductAsync(
        ?\OpenAPI\Client\Model\ProductsCreateRequestBody $products_create_request_body = null,
        string $contentType = self::contentTypes['createProduct'][0]
    ): PromiseInterface
    {
        return $this->createProductAsyncWithHttpInfo($products_create_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createProductAsyncWithHttpInfo
     *
     * Create Product
     *
     * @param  \OpenAPI\Client\Model\ProductsCreateRequestBody|null $products_create_request_body Specify the product parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createProduct'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createProductAsyncWithHttpInfo(
        $products_create_request_body = null,
        string $contentType = self::contentTypes['createProduct'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ProductsCreateResponseBody';
        $request = $this->createProductRequest($products_create_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createProduct'
     *
     * @param  \OpenAPI\Client\Model\ProductsCreateRequestBody|null $products_create_request_body Specify the product parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createProduct'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createProductRequest(
        $products_create_request_body = null,
        string $contentType = self::contentTypes['createProduct'][0]
    ): Request
    {



        $resourcePath = '/v1/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($products_create_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($products_create_request_body));
            } else {
                $httpBody = $products_create_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createSku
     *
     * Create SKU
     *
     * @param  string $product_id A Voucherify product ID or product source ID. (required)
     * @param  \OpenAPI\Client\Model\ProductsSkusCreateRequestBody|null $products_skus_create_request_body Specify the SKU parameters to be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSku'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductsSkusCreateResponseBody
     */
    public function createSku(
        string $product_id,
        ?\OpenAPI\Client\Model\ProductsSkusCreateRequestBody $products_skus_create_request_body = null,
        string $contentType = self::contentTypes['createSku'][0]
    ): \OpenAPI\Client\Model\ProductsSkusCreateResponseBody
    {
        list($response) = $this->createSkuWithHttpInfo($product_id, $products_skus_create_request_body, $contentType);
        return $response;
    }

    /**
     * Operation createSkuWithHttpInfo
     *
     * Create SKU
     *
     * @param  string $product_id A Voucherify product ID or product source ID. (required)
     * @param  \OpenAPI\Client\Model\ProductsSkusCreateRequestBody|null $products_skus_create_request_body Specify the SKU parameters to be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSku'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductsSkusCreateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function createSkuWithHttpInfo(
        string $product_id,
        ?\OpenAPI\Client\Model\ProductsSkusCreateRequestBody $products_skus_create_request_body = null,
        string $contentType = self::contentTypes['createSku'][0]
    ): array
    {
        $request = $this->createSkuRequest($product_id, $products_skus_create_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\OpenAPI\Client\Model\ProductsSkusCreateResponseBody', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductsSkusCreateResponseBody' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductsSkusCreateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProductsSkusCreateResponseBody';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductsSkusCreateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createSkuAsync
     *
     * Create SKU
     *
     * @param  string $product_id A Voucherify product ID or product source ID. (required)
     * @param  \OpenAPI\Client\Model\ProductsSkusCreateRequestBody|null $products_skus_create_request_body Specify the SKU parameters to be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSku'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createSkuAsync(
        string $product_id,
        ?\OpenAPI\Client\Model\ProductsSkusCreateRequestBody $products_skus_create_request_body = null,
        string $contentType = self::contentTypes['createSku'][0]
    ): PromiseInterface
    {
        return $this->createSkuAsyncWithHttpInfo($product_id, $products_skus_create_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createSkuAsyncWithHttpInfo
     *
     * Create SKU
     *
     * @param  string $product_id A Voucherify product ID or product source ID. (required)
     * @param  \OpenAPI\Client\Model\ProductsSkusCreateRequestBody|null $products_skus_create_request_body Specify the SKU parameters to be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSku'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createSkuAsyncWithHttpInfo(
        $product_id,
        $products_skus_create_request_body = null,
        string $contentType = self::contentTypes['createSku'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ProductsSkusCreateResponseBody';
        $request = $this->createSkuRequest($product_id, $products_skus_create_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createSku'
     *
     * @param  string $product_id A Voucherify product ID or product source ID. (required)
     * @param  \OpenAPI\Client\Model\ProductsSkusCreateRequestBody|null $products_skus_create_request_body Specify the SKU parameters to be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSku'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createSkuRequest(
        $product_id,
        $products_skus_create_request_body = null,
        string $contentType = self::contentTypes['createSku'][0]
    ): Request
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $product_id when calling createSku'
            );
        }



        $resourcePath = '/v1/products/{productId}/skus';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($product_id !== null) {
            $resourcePath = str_replace(
                '{' . 'productId' . '}',
                ObjectSerializer::toPathValue($product_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($products_skus_create_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($products_skus_create_request_body));
            } else {
                $httpBody = $products_skus_create_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteProduct
     *
     * Delete Product
     *
     * @param  string $product_id A Voucherify product ID or source ID. (required)
     * @param  bool|null $force If this flag is set to true, the product and all related SKUs will be removed permanently. If it is set to false or not set at all, the product and all related SKUs will be moved to the bin. Going forward, the user will be able to create another product with exactly the same source_id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProduct'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteProduct(
        string $product_id,
        ?bool $force = null,
        string $contentType = self::contentTypes['deleteProduct'][0]
    ): void
    {
        $this->deleteProductWithHttpInfo($product_id, $force, $contentType);
    }

    /**
     * Operation deleteProductWithHttpInfo
     *
     * Delete Product
     *
     * @param  string $product_id A Voucherify product ID or source ID. (required)
     * @param  bool|null $force If this flag is set to true, the product and all related SKUs will be removed permanently. If it is set to false or not set at all, the product and all related SKUs will be moved to the bin. Going forward, the user will be able to create another product with exactly the same source_id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProduct'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteProductWithHttpInfo(
        string $product_id,
        ?bool $force = null,
        string $contentType = self::contentTypes['deleteProduct'][0]
    ): array
    {
        $request = $this->deleteProductRequest($product_id, $force, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteProductAsync
     *
     * Delete Product
     *
     * @param  string $product_id A Voucherify product ID or source ID. (required)
     * @param  bool|null $force If this flag is set to true, the product and all related SKUs will be removed permanently. If it is set to false or not set at all, the product and all related SKUs will be moved to the bin. Going forward, the user will be able to create another product with exactly the same source_id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProduct'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteProductAsync(
        string $product_id,
        ?bool $force = null,
        string $contentType = self::contentTypes['deleteProduct'][0]
    ): PromiseInterface
    {
        return $this->deleteProductAsyncWithHttpInfo($product_id, $force, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteProductAsyncWithHttpInfo
     *
     * Delete Product
     *
     * @param  string $product_id A Voucherify product ID or source ID. (required)
     * @param  bool|null $force If this flag is set to true, the product and all related SKUs will be removed permanently. If it is set to false or not set at all, the product and all related SKUs will be moved to the bin. Going forward, the user will be able to create another product with exactly the same source_id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProduct'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteProductAsyncWithHttpInfo(
        $product_id,
        $force = null,
        string $contentType = self::contentTypes['deleteProduct'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteProductRequest($product_id, $force, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteProduct'
     *
     * @param  string $product_id A Voucherify product ID or source ID. (required)
     * @param  bool|null $force If this flag is set to true, the product and all related SKUs will be removed permanently. If it is set to false or not set at all, the product and all related SKUs will be moved to the bin. Going forward, the user will be able to create another product with exactly the same source_id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteProduct'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteProductRequest(
        $product_id,
        $force = null,
        string $contentType = self::contentTypes['deleteProduct'][0]
    ): Request
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $product_id when calling deleteProduct'
            );
        }



        $resourcePath = '/v1/products/{productId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $force,
            'force', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($product_id !== null) {
            $resourcePath = str_replace(
                '{' . 'productId' . '}',
                ObjectSerializer::toPathValue($product_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteSku
     *
     * Delete SKU
     *
     * @param  string $product_id A unique Voucherify product ID or product source ID. (required)
     * @param  string $sku_id A Voucherify SKU ID or SKU source ID. (required)
     * @param  bool|null $force If this flag is set to true, the SKU will be removed permanently. If it is set to false or not set at all, the SKU will be moved to the bin. Going forward, the user will be able to create another SKU with exactly the same source_id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSku'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteSku(
        string $product_id,
        string $sku_id,
        ?bool $force = null,
        string $contentType = self::contentTypes['deleteSku'][0]
    ): void
    {
        $this->deleteSkuWithHttpInfo($product_id, $sku_id, $force, $contentType);
    }

    /**
     * Operation deleteSkuWithHttpInfo
     *
     * Delete SKU
     *
     * @param  string $product_id A unique Voucherify product ID or product source ID. (required)
     * @param  string $sku_id A Voucherify SKU ID or SKU source ID. (required)
     * @param  bool|null $force If this flag is set to true, the SKU will be removed permanently. If it is set to false or not set at all, the SKU will be moved to the bin. Going forward, the user will be able to create another SKU with exactly the same source_id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSku'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteSkuWithHttpInfo(
        string $product_id,
        string $sku_id,
        ?bool $force = null,
        string $contentType = self::contentTypes['deleteSku'][0]
    ): array
    {
        $request = $this->deleteSkuRequest($product_id, $sku_id, $force, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteSkuAsync
     *
     * Delete SKU
     *
     * @param  string $product_id A unique Voucherify product ID or product source ID. (required)
     * @param  string $sku_id A Voucherify SKU ID or SKU source ID. (required)
     * @param  bool|null $force If this flag is set to true, the SKU will be removed permanently. If it is set to false or not set at all, the SKU will be moved to the bin. Going forward, the user will be able to create another SKU with exactly the same source_id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSku'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteSkuAsync(
        string $product_id,
        string $sku_id,
        ?bool $force = null,
        string $contentType = self::contentTypes['deleteSku'][0]
    ): PromiseInterface
    {
        return $this->deleteSkuAsyncWithHttpInfo($product_id, $sku_id, $force, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteSkuAsyncWithHttpInfo
     *
     * Delete SKU
     *
     * @param  string $product_id A unique Voucherify product ID or product source ID. (required)
     * @param  string $sku_id A Voucherify SKU ID or SKU source ID. (required)
     * @param  bool|null $force If this flag is set to true, the SKU will be removed permanently. If it is set to false or not set at all, the SKU will be moved to the bin. Going forward, the user will be able to create another SKU with exactly the same source_id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSku'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteSkuAsyncWithHttpInfo(
        $product_id,
        $sku_id,
        $force = null,
        string $contentType = self::contentTypes['deleteSku'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteSkuRequest($product_id, $sku_id, $force, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteSku'
     *
     * @param  string $product_id A unique Voucherify product ID or product source ID. (required)
     * @param  string $sku_id A Voucherify SKU ID or SKU source ID. (required)
     * @param  bool|null $force If this flag is set to true, the SKU will be removed permanently. If it is set to false or not set at all, the SKU will be moved to the bin. Going forward, the user will be able to create another SKU with exactly the same source_id. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSku'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteSkuRequest(
        $product_id,
        $sku_id,
        $force = null,
        string $contentType = self::contentTypes['deleteSku'][0]
    ): Request
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $product_id when calling deleteSku'
            );
        }

        // verify the required parameter 'sku_id' is set
        if ($sku_id === null || (is_array($sku_id) && count($sku_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sku_id when calling deleteSku'
            );
        }



        $resourcePath = '/v1/products/{productId}/skus/{skuId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $force,
            'force', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($product_id !== null) {
            $resourcePath = str_replace(
                '{' . 'productId' . '}',
                ObjectSerializer::toPathValue($product_id),
                $resourcePath
            );
        }
        // path params
        if ($sku_id !== null) {
            $resourcePath = str_replace(
                '{' . 'skuId' . '}',
                ObjectSerializer::toPathValue($sku_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProduct
     *
     * Get Product
     *
     * @param  string $product_id A Voucherify product ID or source ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProduct'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductsGetResponseBody
     */
    public function getProduct(
        string $product_id,
        string $contentType = self::contentTypes['getProduct'][0]
    ): \OpenAPI\Client\Model\ProductsGetResponseBody
    {
        list($response) = $this->getProductWithHttpInfo($product_id, $contentType);
        return $response;
    }

    /**
     * Operation getProductWithHttpInfo
     *
     * Get Product
     *
     * @param  string $product_id A Voucherify product ID or source ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProduct'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductsGetResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProductWithHttpInfo(
        string $product_id,
        string $contentType = self::contentTypes['getProduct'][0]
    ): array
    {
        $request = $this->getProductRequest($product_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\OpenAPI\Client\Model\ProductsGetResponseBody', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductsGetResponseBody' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductsGetResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProductsGetResponseBody';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductsGetResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProductAsync
     *
     * Get Product
     *
     * @param  string $product_id A Voucherify product ID or source ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProduct'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getProductAsync(
        string $product_id,
        string $contentType = self::contentTypes['getProduct'][0]
    ): PromiseInterface
    {
        return $this->getProductAsyncWithHttpInfo($product_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProductAsyncWithHttpInfo
     *
     * Get Product
     *
     * @param  string $product_id A Voucherify product ID or source ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProduct'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getProductAsyncWithHttpInfo(
        $product_id,
        string $contentType = self::contentTypes['getProduct'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ProductsGetResponseBody';
        $request = $this->getProductRequest($product_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProduct'
     *
     * @param  string $product_id A Voucherify product ID or source ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProduct'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getProductRequest(
        $product_id,
        string $contentType = self::contentTypes['getProduct'][0]
    ): Request
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $product_id when calling getProduct'
            );
        }


        $resourcePath = '/v1/products/{productId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($product_id !== null) {
            $resourcePath = str_replace(
                '{' . 'productId' . '}',
                ObjectSerializer::toPathValue($product_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSku
     *
     * Get SKU
     *
     * @param  string $sku_id A Voucherify SKU identifier or SKU source ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSku'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\SkusGetResponseBody
     */
    public function getSku(
        string $sku_id,
        string $contentType = self::contentTypes['getSku'][0]
    ): \OpenAPI\Client\Model\SkusGetResponseBody
    {
        list($response) = $this->getSkuWithHttpInfo($sku_id, $contentType);
        return $response;
    }

    /**
     * Operation getSkuWithHttpInfo
     *
     * Get SKU
     *
     * @param  string $sku_id A Voucherify SKU identifier or SKU source ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSku'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SkusGetResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSkuWithHttpInfo(
        string $sku_id,
        string $contentType = self::contentTypes['getSku'][0]
    ): array
    {
        $request = $this->getSkuRequest($sku_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\OpenAPI\Client\Model\SkusGetResponseBody', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SkusGetResponseBody' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SkusGetResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SkusGetResponseBody';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SkusGetResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSkuAsync
     *
     * Get SKU
     *
     * @param  string $sku_id A Voucherify SKU identifier or SKU source ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSku'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getSkuAsync(
        string $sku_id,
        string $contentType = self::contentTypes['getSku'][0]
    ): PromiseInterface
    {
        return $this->getSkuAsyncWithHttpInfo($sku_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSkuAsyncWithHttpInfo
     *
     * Get SKU
     *
     * @param  string $sku_id A Voucherify SKU identifier or SKU source ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSku'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getSkuAsyncWithHttpInfo(
        $sku_id,
        string $contentType = self::contentTypes['getSku'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\SkusGetResponseBody';
        $request = $this->getSkuRequest($sku_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSku'
     *
     * @param  string $sku_id A Voucherify SKU identifier or SKU source ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSku'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSkuRequest(
        $sku_id,
        string $contentType = self::contentTypes['getSku'][0]
    ): Request
    {

        // verify the required parameter 'sku_id' is set
        if ($sku_id === null || (is_array($sku_id) && count($sku_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sku_id when calling getSku'
            );
        }


        $resourcePath = '/v1/skus/{skuId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sku_id !== null) {
            $resourcePath = str_replace(
                '{' . 'skuId' . '}',
                ObjectSerializer::toPathValue($sku_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation importProductsUsingCsv
     *
     * Import Products using CSV
     *
     * @param  \SplFileObject|null $file File path. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importProductsUsingCsv'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductsImportCsvCreateResponseBody
     */
    public function importProductsUsingCsv(
        ?\SplFileObject $file = null,
        string $contentType = self::contentTypes['importProductsUsingCsv'][0]
    ): \OpenAPI\Client\Model\ProductsImportCsvCreateResponseBody
    {
        list($response) = $this->importProductsUsingCsvWithHttpInfo($file, $contentType);
        return $response;
    }

    /**
     * Operation importProductsUsingCsvWithHttpInfo
     *
     * Import Products using CSV
     *
     * @param  \SplFileObject|null $file File path. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importProductsUsingCsv'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductsImportCsvCreateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function importProductsUsingCsvWithHttpInfo(
        ?\SplFileObject $file = null,
        string $contentType = self::contentTypes['importProductsUsingCsv'][0]
    ): array
    {
        $request = $this->importProductsUsingCsvRequest($file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\OpenAPI\Client\Model\ProductsImportCsvCreateResponseBody', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductsImportCsvCreateResponseBody' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductsImportCsvCreateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProductsImportCsvCreateResponseBody';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductsImportCsvCreateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation importProductsUsingCsvAsync
     *
     * Import Products using CSV
     *
     * @param  \SplFileObject|null $file File path. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importProductsUsingCsv'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function importProductsUsingCsvAsync(
        ?\SplFileObject $file = null,
        string $contentType = self::contentTypes['importProductsUsingCsv'][0]
    ): PromiseInterface
    {
        return $this->importProductsUsingCsvAsyncWithHttpInfo($file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importProductsUsingCsvAsyncWithHttpInfo
     *
     * Import Products using CSV
     *
     * @param  \SplFileObject|null $file File path. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importProductsUsingCsv'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function importProductsUsingCsvAsyncWithHttpInfo(
        $file = null,
        string $contentType = self::contentTypes['importProductsUsingCsv'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ProductsImportCsvCreateResponseBody';
        $request = $this->importProductsUsingCsvRequest($file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importProductsUsingCsv'
     *
     * @param  \SplFileObject|null $file File path. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importProductsUsingCsv'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function importProductsUsingCsvRequest(
        $file = null,
        string $contentType = self::contentTypes['importProductsUsingCsv'][0]
    ): Request
    {



        $resourcePath = '/v1/products/importCSV';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = [];
            $paramFiles = is_array($file) ? $file : [$file];
            foreach ($paramFiles as $paramFile) {
                $formParams['file'][] = $paramFile instanceof \Psr\Http\Message\StreamInterface
                    ? $paramFile
                    : \GuzzleHttp\Psr7\Utils::tryFopen(
                        ObjectSerializer::toFormValue($paramFile),
                        'rb'
                    );
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation importSkusUsingCsv
     *
     * Import SKUs using CSV
     *
     * @param  \SplFileObject|null $file File path. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importSkusUsingCsv'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\SkusImportCsvCreateResponseBody
     */
    public function importSkusUsingCsv(
        ?\SplFileObject $file = null,
        string $contentType = self::contentTypes['importSkusUsingCsv'][0]
    ): \OpenAPI\Client\Model\SkusImportCsvCreateResponseBody
    {
        list($response) = $this->importSkusUsingCsvWithHttpInfo($file, $contentType);
        return $response;
    }

    /**
     * Operation importSkusUsingCsvWithHttpInfo
     *
     * Import SKUs using CSV
     *
     * @param  \SplFileObject|null $file File path. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importSkusUsingCsv'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SkusImportCsvCreateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function importSkusUsingCsvWithHttpInfo(
        ?\SplFileObject $file = null,
        string $contentType = self::contentTypes['importSkusUsingCsv'][0]
    ): array
    {
        $request = $this->importSkusUsingCsvRequest($file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\OpenAPI\Client\Model\SkusImportCsvCreateResponseBody', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SkusImportCsvCreateResponseBody' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SkusImportCsvCreateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SkusImportCsvCreateResponseBody';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SkusImportCsvCreateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation importSkusUsingCsvAsync
     *
     * Import SKUs using CSV
     *
     * @param  \SplFileObject|null $file File path. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importSkusUsingCsv'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function importSkusUsingCsvAsync(
        ?\SplFileObject $file = null,
        string $contentType = self::contentTypes['importSkusUsingCsv'][0]
    ): PromiseInterface
    {
        return $this->importSkusUsingCsvAsyncWithHttpInfo($file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importSkusUsingCsvAsyncWithHttpInfo
     *
     * Import SKUs using CSV
     *
     * @param  \SplFileObject|null $file File path. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importSkusUsingCsv'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function importSkusUsingCsvAsyncWithHttpInfo(
        $file = null,
        string $contentType = self::contentTypes['importSkusUsingCsv'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\SkusImportCsvCreateResponseBody';
        $request = $this->importSkusUsingCsvRequest($file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importSkusUsingCsv'
     *
     * @param  \SplFileObject|null $file File path. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importSkusUsingCsv'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function importSkusUsingCsvRequest(
        $file = null,
        string $contentType = self::contentTypes['importSkusUsingCsv'][0]
    ): Request
    {



        $resourcePath = '/v1/skus/importCSV';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = [];
            $paramFiles = is_array($file) ? $file : [$file];
            foreach ($paramFiles as $paramFile) {
                $formParams['file'][] = $paramFile instanceof \Psr\Http\Message\StreamInterface
                    ? $paramFile
                    : \GuzzleHttp\Psr7\Utils::tryFopen(
                        ObjectSerializer::toFormValue($paramFile),
                        'rb'
                    );
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listProducts
     *
     * List Products
     *
     * @param  int|null $limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param  int|null $page Which page of results to return. The lowest value is 1. (optional)
     * @param  ParameterOrder|null $order Sorts the results using one of the filtering options, where the dash - preceding a sorting option means sorting in a descending order. (optional)
     * @param  \DateTime|null $start_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param  \DateTime|null $end_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listProducts'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductsListResponseBody
     */
    public function listProducts(
        ?int $limit = null,
        ?int $page = null,
        ?ParameterOrder $order = null,
        ?\DateTime $start_date = null,
        ?\DateTime $end_date = null,
        string $contentType = self::contentTypes['listProducts'][0]
    ): \OpenAPI\Client\Model\ProductsListResponseBody
    {
        list($response) = $this->listProductsWithHttpInfo($limit, $page, $order, $start_date, $end_date, $contentType);
        return $response;
    }

    /**
     * Operation listProductsWithHttpInfo
     *
     * List Products
     *
     * @param  int|null $limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param  int|null $page Which page of results to return. The lowest value is 1. (optional)
     * @param  ParameterOrder|null $order Sorts the results using one of the filtering options, where the dash - preceding a sorting option means sorting in a descending order. (optional)
     * @param  \DateTime|null $start_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param  \DateTime|null $end_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listProducts'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductsListResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listProductsWithHttpInfo(
        ?int $limit = null,
        ?int $page = null,
        ?ParameterOrder $order = null,
        ?\DateTime $start_date = null,
        ?\DateTime $end_date = null,
        string $contentType = self::contentTypes['listProducts'][0]
    ): array
    {
        $request = $this->listProductsRequest($limit, $page, $order, $start_date, $end_date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\OpenAPI\Client\Model\ProductsListResponseBody', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductsListResponseBody' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductsListResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProductsListResponseBody';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductsListResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listProductsAsync
     *
     * List Products
     *
     * @param  int|null $limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param  int|null $page Which page of results to return. The lowest value is 1. (optional)
     * @param  ParameterOrder|null $order Sorts the results using one of the filtering options, where the dash - preceding a sorting option means sorting in a descending order. (optional)
     * @param  \DateTime|null $start_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param  \DateTime|null $end_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listProducts'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listProductsAsync(
        ?int $limit = null,
        ?int $page = null,
        ?ParameterOrder $order = null,
        ?\DateTime $start_date = null,
        ?\DateTime $end_date = null,
        string $contentType = self::contentTypes['listProducts'][0]
    ): PromiseInterface
    {
        return $this->listProductsAsyncWithHttpInfo($limit, $page, $order, $start_date, $end_date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listProductsAsyncWithHttpInfo
     *
     * List Products
     *
     * @param  int|null $limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param  int|null $page Which page of results to return. The lowest value is 1. (optional)
     * @param  ParameterOrder|null $order Sorts the results using one of the filtering options, where the dash - preceding a sorting option means sorting in a descending order. (optional)
     * @param  \DateTime|null $start_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param  \DateTime|null $end_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listProducts'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listProductsAsyncWithHttpInfo(
        $limit = null,
        $page = null,
        $order = null,
        $start_date = null,
        $end_date = null,
        string $contentType = self::contentTypes['listProducts'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ProductsListResponseBody';
        $request = $this->listProductsRequest($limit, $page, $order, $start_date, $end_date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listProducts'
     *
     * @param  int|null $limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param  int|null $page Which page of results to return. The lowest value is 1. (optional)
     * @param  ParameterOrder|null $order Sorts the results using one of the filtering options, where the dash - preceding a sorting option means sorting in a descending order. (optional)
     * @param  \DateTime|null $start_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param  \DateTime|null $end_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listProducts'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listProductsRequest(
        $limit = null,
        $page = null,
        $order = null,
        $start_date = null,
        $end_date = null,
        string $contentType = self::contentTypes['listProducts'][0]
    ): Request
    {

        if ($limit !== null && $limit > 100) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling ProductsApi.listProducts, must be smaller than or equal to 100.');
        }
        if ($limit !== null && $limit < 1) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling ProductsApi.listProducts, must be bigger than or equal to 1.');
        }
        
        if ($page !== null && $page > 100) {
            throw new InvalidArgumentException('invalid value for "$page" when calling ProductsApi.listProducts, must be smaller than or equal to 100.');
        }
        if ($page !== null && $page < 1) {
            throw new InvalidArgumentException('invalid value for "$page" when calling ProductsApi.listProducts, must be bigger than or equal to 1.');
        }
        




        $resourcePath = '/v1/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'ParameterOrder', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'start_date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'end_date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listSkusInProduct
     *
     * List SKUs in Product
     *
     * @param  string $product_id A Voucherify product ID or product source ID. (required)
     * @param  int|null $limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param  int|null $page Which page of results to return. The lowest value is 1. (optional)
     * @param  ParameterOrder|null $order Sorts the results using one of the filtering options, where the dash - preceding a sorting option means sorting in a descending order. (optional)
     * @param  \DateTime|null $start_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param  \DateTime|null $end_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSkusInProduct'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductsSkusListResponseBody
     */
    public function listSkusInProduct(
        string $product_id,
        ?int $limit = null,
        ?int $page = null,
        ?ParameterOrder $order = null,
        ?\DateTime $start_date = null,
        ?\DateTime $end_date = null,
        string $contentType = self::contentTypes['listSkusInProduct'][0]
    ): \OpenAPI\Client\Model\ProductsSkusListResponseBody
    {
        list($response) = $this->listSkusInProductWithHttpInfo($product_id, $limit, $page, $order, $start_date, $end_date, $contentType);
        return $response;
    }

    /**
     * Operation listSkusInProductWithHttpInfo
     *
     * List SKUs in Product
     *
     * @param  string $product_id A Voucherify product ID or product source ID. (required)
     * @param  int|null $limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param  int|null $page Which page of results to return. The lowest value is 1. (optional)
     * @param  ParameterOrder|null $order Sorts the results using one of the filtering options, where the dash - preceding a sorting option means sorting in a descending order. (optional)
     * @param  \DateTime|null $start_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param  \DateTime|null $end_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSkusInProduct'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductsSkusListResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listSkusInProductWithHttpInfo(
        string $product_id,
        ?int $limit = null,
        ?int $page = null,
        ?ParameterOrder $order = null,
        ?\DateTime $start_date = null,
        ?\DateTime $end_date = null,
        string $contentType = self::contentTypes['listSkusInProduct'][0]
    ): array
    {
        $request = $this->listSkusInProductRequest($product_id, $limit, $page, $order, $start_date, $end_date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\OpenAPI\Client\Model\ProductsSkusListResponseBody', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductsSkusListResponseBody' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductsSkusListResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProductsSkusListResponseBody';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductsSkusListResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listSkusInProductAsync
     *
     * List SKUs in Product
     *
     * @param  string $product_id A Voucherify product ID or product source ID. (required)
     * @param  int|null $limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param  int|null $page Which page of results to return. The lowest value is 1. (optional)
     * @param  ParameterOrder|null $order Sorts the results using one of the filtering options, where the dash - preceding a sorting option means sorting in a descending order. (optional)
     * @param  \DateTime|null $start_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param  \DateTime|null $end_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSkusInProduct'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listSkusInProductAsync(
        string $product_id,
        ?int $limit = null,
        ?int $page = null,
        ?ParameterOrder $order = null,
        ?\DateTime $start_date = null,
        ?\DateTime $end_date = null,
        string $contentType = self::contentTypes['listSkusInProduct'][0]
    ): PromiseInterface
    {
        return $this->listSkusInProductAsyncWithHttpInfo($product_id, $limit, $page, $order, $start_date, $end_date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listSkusInProductAsyncWithHttpInfo
     *
     * List SKUs in Product
     *
     * @param  string $product_id A Voucherify product ID or product source ID. (required)
     * @param  int|null $limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param  int|null $page Which page of results to return. The lowest value is 1. (optional)
     * @param  ParameterOrder|null $order Sorts the results using one of the filtering options, where the dash - preceding a sorting option means sorting in a descending order. (optional)
     * @param  \DateTime|null $start_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param  \DateTime|null $end_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSkusInProduct'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listSkusInProductAsyncWithHttpInfo(
        $product_id,
        $limit = null,
        $page = null,
        $order = null,
        $start_date = null,
        $end_date = null,
        string $contentType = self::contentTypes['listSkusInProduct'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ProductsSkusListResponseBody';
        $request = $this->listSkusInProductRequest($product_id, $limit, $page, $order, $start_date, $end_date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listSkusInProduct'
     *
     * @param  string $product_id A Voucherify product ID or product source ID. (required)
     * @param  int|null $limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param  int|null $page Which page of results to return. The lowest value is 1. (optional)
     * @param  ParameterOrder|null $order Sorts the results using one of the filtering options, where the dash - preceding a sorting option means sorting in a descending order. (optional)
     * @param  \DateTime|null $start_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param  \DateTime|null $end_date Timestamp representing the date and time which results must end on. Represented in ISO 8601 format. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSkusInProduct'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listSkusInProductRequest(
        $product_id,
        $limit = null,
        $page = null,
        $order = null,
        $start_date = null,
        $end_date = null,
        string $contentType = self::contentTypes['listSkusInProduct'][0]
    ): Request
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $product_id when calling listSkusInProduct'
            );
        }

        if ($limit !== null && $limit > 100) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling ProductsApi.listSkusInProduct, must be smaller than or equal to 100.');
        }
        if ($limit !== null && $limit < 1) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling ProductsApi.listSkusInProduct, must be bigger than or equal to 1.');
        }
        
        if ($page !== null && $page > 100) {
            throw new InvalidArgumentException('invalid value for "$page" when calling ProductsApi.listSkusInProduct, must be smaller than or equal to 100.');
        }
        if ($page !== null && $page < 1) {
            throw new InvalidArgumentException('invalid value for "$page" when calling ProductsApi.listSkusInProduct, must be bigger than or equal to 1.');
        }
        




        $resourcePath = '/v1/products/{productId}/skus';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'ParameterOrder', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'start_date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'end_date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($product_id !== null) {
            $resourcePath = str_replace(
                '{' . 'productId' . '}',
                ObjectSerializer::toPathValue($product_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateProduct
     *
     * Update Product
     *
     * @param  string $product_id A Voucherify product ID or source ID. (required)
     * @param  \OpenAPI\Client\Model\ProductsUpdateRequestBody|null $products_update_request_body Specify the parameters of the product that are to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProduct'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductsUpdateResponseBody
     */
    public function updateProduct(
        string $product_id,
        ?\OpenAPI\Client\Model\ProductsUpdateRequestBody $products_update_request_body = null,
        string $contentType = self::contentTypes['updateProduct'][0]
    ): \OpenAPI\Client\Model\ProductsUpdateResponseBody
    {
        list($response) = $this->updateProductWithHttpInfo($product_id, $products_update_request_body, $contentType);
        return $response;
    }

    /**
     * Operation updateProductWithHttpInfo
     *
     * Update Product
     *
     * @param  string $product_id A Voucherify product ID or source ID. (required)
     * @param  \OpenAPI\Client\Model\ProductsUpdateRequestBody|null $products_update_request_body Specify the parameters of the product that are to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProduct'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductsUpdateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateProductWithHttpInfo(
        string $product_id,
        ?\OpenAPI\Client\Model\ProductsUpdateRequestBody $products_update_request_body = null,
        string $contentType = self::contentTypes['updateProduct'][0]
    ): array
    {
        $request = $this->updateProductRequest($product_id, $products_update_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\OpenAPI\Client\Model\ProductsUpdateResponseBody', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductsUpdateResponseBody' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductsUpdateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProductsUpdateResponseBody';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductsUpdateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateProductAsync
     *
     * Update Product
     *
     * @param  string $product_id A Voucherify product ID or source ID. (required)
     * @param  \OpenAPI\Client\Model\ProductsUpdateRequestBody|null $products_update_request_body Specify the parameters of the product that are to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProduct'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateProductAsync(
        string $product_id,
        ?\OpenAPI\Client\Model\ProductsUpdateRequestBody $products_update_request_body = null,
        string $contentType = self::contentTypes['updateProduct'][0]
    ): PromiseInterface
    {
        return $this->updateProductAsyncWithHttpInfo($product_id, $products_update_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateProductAsyncWithHttpInfo
     *
     * Update Product
     *
     * @param  string $product_id A Voucherify product ID or source ID. (required)
     * @param  \OpenAPI\Client\Model\ProductsUpdateRequestBody|null $products_update_request_body Specify the parameters of the product that are to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProduct'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateProductAsyncWithHttpInfo(
        $product_id,
        $products_update_request_body = null,
        string $contentType = self::contentTypes['updateProduct'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ProductsUpdateResponseBody';
        $request = $this->updateProductRequest($product_id, $products_update_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateProduct'
     *
     * @param  string $product_id A Voucherify product ID or source ID. (required)
     * @param  \OpenAPI\Client\Model\ProductsUpdateRequestBody|null $products_update_request_body Specify the parameters of the product that are to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProduct'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateProductRequest(
        $product_id,
        $products_update_request_body = null,
        string $contentType = self::contentTypes['updateProduct'][0]
    ): Request
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $product_id when calling updateProduct'
            );
        }



        $resourcePath = '/v1/products/{productId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($product_id !== null) {
            $resourcePath = str_replace(
                '{' . 'productId' . '}',
                ObjectSerializer::toPathValue($product_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($products_update_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($products_update_request_body));
            } else {
                $httpBody = $products_update_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateProductsInBulk
     *
     * Update Products in bulk
     *
     * @param  \OpenAPI\Client\Model\ProductsUpdateInBulkRequestBody[]|null $products_update_in_bulk_request_body Create an array of product objects, each with the parameters which you want to update. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProductsInBulk'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductsUpdateInBulkResponseBody
     */
    public function updateProductsInBulk(
        ?array $products_update_in_bulk_request_body = null,
        string $contentType = self::contentTypes['updateProductsInBulk'][0]
    ): \OpenAPI\Client\Model\ProductsUpdateInBulkResponseBody
    {
        list($response) = $this->updateProductsInBulkWithHttpInfo($products_update_in_bulk_request_body, $contentType);
        return $response;
    }

    /**
     * Operation updateProductsInBulkWithHttpInfo
     *
     * Update Products in bulk
     *
     * @param  \OpenAPI\Client\Model\ProductsUpdateInBulkRequestBody[]|null $products_update_in_bulk_request_body Create an array of product objects, each with the parameters which you want to update. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProductsInBulk'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductsUpdateInBulkResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateProductsInBulkWithHttpInfo(
        ?array $products_update_in_bulk_request_body = null,
        string $contentType = self::contentTypes['updateProductsInBulk'][0]
    ): array
    {
        $request = $this->updateProductsInBulkRequest($products_update_in_bulk_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 202:
                    if (in_array('\OpenAPI\Client\Model\ProductsUpdateInBulkResponseBody', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductsUpdateInBulkResponseBody' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductsUpdateInBulkResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProductsUpdateInBulkResponseBody';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductsUpdateInBulkResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateProductsInBulkAsync
     *
     * Update Products in bulk
     *
     * @param  \OpenAPI\Client\Model\ProductsUpdateInBulkRequestBody[]|null $products_update_in_bulk_request_body Create an array of product objects, each with the parameters which you want to update. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProductsInBulk'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateProductsInBulkAsync(
        ?array $products_update_in_bulk_request_body = null,
        string $contentType = self::contentTypes['updateProductsInBulk'][0]
    ): PromiseInterface
    {
        return $this->updateProductsInBulkAsyncWithHttpInfo($products_update_in_bulk_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateProductsInBulkAsyncWithHttpInfo
     *
     * Update Products in bulk
     *
     * @param  \OpenAPI\Client\Model\ProductsUpdateInBulkRequestBody[]|null $products_update_in_bulk_request_body Create an array of product objects, each with the parameters which you want to update. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProductsInBulk'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateProductsInBulkAsyncWithHttpInfo(
        $products_update_in_bulk_request_body = null,
        string $contentType = self::contentTypes['updateProductsInBulk'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ProductsUpdateInBulkResponseBody';
        $request = $this->updateProductsInBulkRequest($products_update_in_bulk_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateProductsInBulk'
     *
     * @param  \OpenAPI\Client\Model\ProductsUpdateInBulkRequestBody[]|null $products_update_in_bulk_request_body Create an array of product objects, each with the parameters which you want to update. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProductsInBulk'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateProductsInBulkRequest(
        $products_update_in_bulk_request_body = null,
        string $contentType = self::contentTypes['updateProductsInBulk'][0]
    ): Request
    {



        $resourcePath = '/v1/products/bulk/async';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($products_update_in_bulk_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($products_update_in_bulk_request_body));
            } else {
                $httpBody = $products_update_in_bulk_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateProductsMetadataInBulk
     *
     * Update Products&#39; Metadata in bulk
     *
     * @param  \OpenAPI\Client\Model\ProductsMetadataUpdateInBulkRequestBody|null $products_metadata_update_in_bulk_request_body Specify the list of product source IDs and the metadata key value pairs to be udpated for these products. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProductsMetadataInBulk'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductsMetadataUpdateInBulkResponseBody
     */
    public function updateProductsMetadataInBulk(
        ?\OpenAPI\Client\Model\ProductsMetadataUpdateInBulkRequestBody $products_metadata_update_in_bulk_request_body = null,
        string $contentType = self::contentTypes['updateProductsMetadataInBulk'][0]
    ): \OpenAPI\Client\Model\ProductsMetadataUpdateInBulkResponseBody
    {
        list($response) = $this->updateProductsMetadataInBulkWithHttpInfo($products_metadata_update_in_bulk_request_body, $contentType);
        return $response;
    }

    /**
     * Operation updateProductsMetadataInBulkWithHttpInfo
     *
     * Update Products&#39; Metadata in bulk
     *
     * @param  \OpenAPI\Client\Model\ProductsMetadataUpdateInBulkRequestBody|null $products_metadata_update_in_bulk_request_body Specify the list of product source IDs and the metadata key value pairs to be udpated for these products. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProductsMetadataInBulk'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductsMetadataUpdateInBulkResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateProductsMetadataInBulkWithHttpInfo(
        ?\OpenAPI\Client\Model\ProductsMetadataUpdateInBulkRequestBody $products_metadata_update_in_bulk_request_body = null,
        string $contentType = self::contentTypes['updateProductsMetadataInBulk'][0]
    ): array
    {
        $request = $this->updateProductsMetadataInBulkRequest($products_metadata_update_in_bulk_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 202:
                    if (in_array('\OpenAPI\Client\Model\ProductsMetadataUpdateInBulkResponseBody', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductsMetadataUpdateInBulkResponseBody' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductsMetadataUpdateInBulkResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProductsMetadataUpdateInBulkResponseBody';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductsMetadataUpdateInBulkResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateProductsMetadataInBulkAsync
     *
     * Update Products&#39; Metadata in bulk
     *
     * @param  \OpenAPI\Client\Model\ProductsMetadataUpdateInBulkRequestBody|null $products_metadata_update_in_bulk_request_body Specify the list of product source IDs and the metadata key value pairs to be udpated for these products. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProductsMetadataInBulk'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateProductsMetadataInBulkAsync(
        ?\OpenAPI\Client\Model\ProductsMetadataUpdateInBulkRequestBody $products_metadata_update_in_bulk_request_body = null,
        string $contentType = self::contentTypes['updateProductsMetadataInBulk'][0]
    ): PromiseInterface
    {
        return $this->updateProductsMetadataInBulkAsyncWithHttpInfo($products_metadata_update_in_bulk_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateProductsMetadataInBulkAsyncWithHttpInfo
     *
     * Update Products&#39; Metadata in bulk
     *
     * @param  \OpenAPI\Client\Model\ProductsMetadataUpdateInBulkRequestBody|null $products_metadata_update_in_bulk_request_body Specify the list of product source IDs and the metadata key value pairs to be udpated for these products. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProductsMetadataInBulk'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateProductsMetadataInBulkAsyncWithHttpInfo(
        $products_metadata_update_in_bulk_request_body = null,
        string $contentType = self::contentTypes['updateProductsMetadataInBulk'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ProductsMetadataUpdateInBulkResponseBody';
        $request = $this->updateProductsMetadataInBulkRequest($products_metadata_update_in_bulk_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateProductsMetadataInBulk'
     *
     * @param  \OpenAPI\Client\Model\ProductsMetadataUpdateInBulkRequestBody|null $products_metadata_update_in_bulk_request_body Specify the list of product source IDs and the metadata key value pairs to be udpated for these products. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateProductsMetadataInBulk'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateProductsMetadataInBulkRequest(
        $products_metadata_update_in_bulk_request_body = null,
        string $contentType = self::contentTypes['updateProductsMetadataInBulk'][0]
    ): Request
    {



        $resourcePath = '/v1/products/metadata/async';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($products_metadata_update_in_bulk_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($products_metadata_update_in_bulk_request_body));
            } else {
                $httpBody = $products_metadata_update_in_bulk_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateSku
     *
     * Update SKU
     *
     * @param  string $product_id A unique Voucherify product ID or product source ID. (required)
     * @param  string $sku_id A Voucherify SKU ID or SKU source ID. (required)
     * @param  \OpenAPI\Client\Model\ProductsSkusUpdateRequestBody|null $products_skus_update_request_body Specify the parameters to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSku'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductsSkusUpdateResponseBody
     */
    public function updateSku(
        string $product_id,
        string $sku_id,
        ?\OpenAPI\Client\Model\ProductsSkusUpdateRequestBody $products_skus_update_request_body = null,
        string $contentType = self::contentTypes['updateSku'][0]
    ): \OpenAPI\Client\Model\ProductsSkusUpdateResponseBody
    {
        list($response) = $this->updateSkuWithHttpInfo($product_id, $sku_id, $products_skus_update_request_body, $contentType);
        return $response;
    }

    /**
     * Operation updateSkuWithHttpInfo
     *
     * Update SKU
     *
     * @param  string $product_id A unique Voucherify product ID or product source ID. (required)
     * @param  string $sku_id A Voucherify SKU ID or SKU source ID. (required)
     * @param  \OpenAPI\Client\Model\ProductsSkusUpdateRequestBody|null $products_skus_update_request_body Specify the parameters to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSku'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductsSkusUpdateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateSkuWithHttpInfo(
        string $product_id,
        string $sku_id,
        ?\OpenAPI\Client\Model\ProductsSkusUpdateRequestBody $products_skus_update_request_body = null,
        string $contentType = self::contentTypes['updateSku'][0]
    ): array
    {
        $request = $this->updateSkuRequest($product_id, $sku_id, $products_skus_update_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\OpenAPI\Client\Model\ProductsSkusUpdateResponseBody', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductsSkusUpdateResponseBody' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductsSkusUpdateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProductsSkusUpdateResponseBody';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductsSkusUpdateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateSkuAsync
     *
     * Update SKU
     *
     * @param  string $product_id A unique Voucherify product ID or product source ID. (required)
     * @param  string $sku_id A Voucherify SKU ID or SKU source ID. (required)
     * @param  \OpenAPI\Client\Model\ProductsSkusUpdateRequestBody|null $products_skus_update_request_body Specify the parameters to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSku'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateSkuAsync(
        string $product_id,
        string $sku_id,
        ?\OpenAPI\Client\Model\ProductsSkusUpdateRequestBody $products_skus_update_request_body = null,
        string $contentType = self::contentTypes['updateSku'][0]
    ): PromiseInterface
    {
        return $this->updateSkuAsyncWithHttpInfo($product_id, $sku_id, $products_skus_update_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateSkuAsyncWithHttpInfo
     *
     * Update SKU
     *
     * @param  string $product_id A unique Voucherify product ID or product source ID. (required)
     * @param  string $sku_id A Voucherify SKU ID or SKU source ID. (required)
     * @param  \OpenAPI\Client\Model\ProductsSkusUpdateRequestBody|null $products_skus_update_request_body Specify the parameters to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSku'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateSkuAsyncWithHttpInfo(
        $product_id,
        $sku_id,
        $products_skus_update_request_body = null,
        string $contentType = self::contentTypes['updateSku'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ProductsSkusUpdateResponseBody';
        $request = $this->updateSkuRequest($product_id, $sku_id, $products_skus_update_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateSku'
     *
     * @param  string $product_id A unique Voucherify product ID or product source ID. (required)
     * @param  string $sku_id A Voucherify SKU ID or SKU source ID. (required)
     * @param  \OpenAPI\Client\Model\ProductsSkusUpdateRequestBody|null $products_skus_update_request_body Specify the parameters to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSku'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateSkuRequest(
        $product_id,
        $sku_id,
        $products_skus_update_request_body = null,
        string $contentType = self::contentTypes['updateSku'][0]
    ): Request
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $product_id when calling updateSku'
            );
        }

        // verify the required parameter 'sku_id' is set
        if ($sku_id === null || (is_array($sku_id) && count($sku_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sku_id when calling updateSku'
            );
        }



        $resourcePath = '/v1/products/{productId}/skus/{skuId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($product_id !== null) {
            $resourcePath = str_replace(
                '{' . 'productId' . '}',
                ObjectSerializer::toPathValue($product_id),
                $resourcePath
            );
        }
        // path params
        if ($sku_id !== null) {
            $resourcePath = str_replace(
                '{' . 'skuId' . '}',
                ObjectSerializer::toPathValue($sku_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($products_skus_update_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($products_skus_update_request_body));
            } else {
                $httpBody = $products_skus_update_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
