<?php
/**
 * VouchersApi
 * PHP version 8.1
 *
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Voucherify API
 *
 * Voucherify promotion engine REST API. Please see https://docs.voucherify.io/docs for more details.
 *
 * The version of the OpenAPI document: v2018-08-01
 * Contact: support@voucherify.io
 * @generated Generated by: https://openapi-generator.tech
 * Generator version: 7.7.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use InvalidArgumentException;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\Promise\PromiseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * VouchersApi Class Doc Comment
 *
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class VouchersApi
{
    /**
     * @var ClientInterface
     */
    protected ClientInterface $client;

    /**
     * @var Configuration
     */
    protected Configuration $config;

    /**
     * @var HeaderSelector
     */
    protected HeaderSelector $headerSelector;

    /**
     * @var int Host index
     */
    protected int $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createVoucher' => [
            'application/json',
        ],
        'deleteVoucher' => [
            'application/json',
        ],
        'disableVoucher' => [
            'application/json',
        ],
        'enableVoucher' => [
            'application/json',
        ],
        'exportVoucherTransactions' => [
            'application/json',
        ],
        'generateRandomCode' => [
            'application/json',
        ],
        'getVoucher' => [
            'application/json',
        ],
        'importVouchersUsingCsv' => [
            'multipart/form-data',
        ],
        'listVoucherTransactions' => [
            'application/json',
        ],
        'listVouchers' => [
            'application/json',
        ],
        'releaseValidationSession' => [
            'application/json',
        ],
        'updateVoucher' => [
            'application/json',
        ],
        'updateVoucherBalance' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface|null $client
     * @param Configuration|null   $config
     * @param HeaderSelector|null  $selector
     * @param int                  $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * Operation createVoucher
     *
     * Create Voucher
     *
     * @param  string $code A unique **code** that identifies the voucher. (required)
     * @param  \OpenAPI\Client\Model\VouchersCreateWithWithSpecificCodeRequestBody|null $vouchers_create_with_with_specific_code_request_body Specify the details of the voucher that you would like to create. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVoucher'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\VouchersCreateResponseBody
     */
    public function createVoucher(
        string $code,
        ?\OpenAPI\Client\Model\VouchersCreateWithWithSpecificCodeRequestBody $vouchers_create_with_with_specific_code_request_body = null,
        string $contentType = self::contentTypes['createVoucher'][0]
    ): \OpenAPI\Client\Model\VouchersCreateResponseBody
    {
        list($response) = $this->createVoucherWithHttpInfo($code, $vouchers_create_with_with_specific_code_request_body, $contentType);
        return $response;
    }

    /**
     * Operation createVoucherWithHttpInfo
     *
     * Create Voucher
     *
     * @param  string $code A unique **code** that identifies the voucher. (required)
     * @param  \OpenAPI\Client\Model\VouchersCreateWithWithSpecificCodeRequestBody|null $vouchers_create_with_with_specific_code_request_body Specify the details of the voucher that you would like to create. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVoucher'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VouchersCreateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function createVoucherWithHttpInfo(
        string $code,
        ?\OpenAPI\Client\Model\VouchersCreateWithWithSpecificCodeRequestBody $vouchers_create_with_with_specific_code_request_body = null,
        string $contentType = self::contentTypes['createVoucher'][0]
    ): array
    {
        $request = $this->createVoucherRequest($code, $vouchers_create_with_with_specific_code_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\OpenAPI\Client\Model\VouchersCreateResponseBody', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VouchersCreateResponseBody' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VouchersCreateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VouchersCreateResponseBody';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VouchersCreateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createVoucherAsync
     *
     * Create Voucher
     *
     * @param  string $code A unique **code** that identifies the voucher. (required)
     * @param  \OpenAPI\Client\Model\VouchersCreateWithWithSpecificCodeRequestBody|null $vouchers_create_with_with_specific_code_request_body Specify the details of the voucher that you would like to create. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVoucher'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createVoucherAsync(
        string $code,
        ?\OpenAPI\Client\Model\VouchersCreateWithWithSpecificCodeRequestBody $vouchers_create_with_with_specific_code_request_body = null,
        string $contentType = self::contentTypes['createVoucher'][0]
    ): PromiseInterface
    {
        return $this->createVoucherAsyncWithHttpInfo($code, $vouchers_create_with_with_specific_code_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createVoucherAsyncWithHttpInfo
     *
     * Create Voucher
     *
     * @param  string $code A unique **code** that identifies the voucher. (required)
     * @param  \OpenAPI\Client\Model\VouchersCreateWithWithSpecificCodeRequestBody|null $vouchers_create_with_with_specific_code_request_body Specify the details of the voucher that you would like to create. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVoucher'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createVoucherAsyncWithHttpInfo(
        $code,
        $vouchers_create_with_with_specific_code_request_body = null,
        string $contentType = self::contentTypes['createVoucher'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\VouchersCreateResponseBody';
        $request = $this->createVoucherRequest($code, $vouchers_create_with_with_specific_code_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createVoucher'
     *
     * @param  string $code A unique **code** that identifies the voucher. (required)
     * @param  \OpenAPI\Client\Model\VouchersCreateWithWithSpecificCodeRequestBody|null $vouchers_create_with_with_specific_code_request_body Specify the details of the voucher that you would like to create. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVoucher'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createVoucherRequest(
        $code,
        $vouchers_create_with_with_specific_code_request_body = null,
        string $contentType = self::contentTypes['createVoucher'][0]
    ): Request
    {

        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $code when calling createVoucher'
            );
        }



        $resourcePath = '/v1/vouchers/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vouchers_create_with_with_specific_code_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vouchers_create_with_with_specific_code_request_body));
            } else {
                $httpBody = $vouchers_create_with_with_specific_code_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteVoucher
     *
     * Delete Voucher
     *
     * @param  string $code A unique **code** that identifies the voucher. (required)
     * @param  bool|null $force If this flag is set to true, the voucher will be removed permanently. If it is set to false or not set at all, the voucher will be moved to the bin. Going forward, the user will be able to create another voucher with exactly the same code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVoucher'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteVoucher(
        string $code,
        ?bool $force = null,
        string $contentType = self::contentTypes['deleteVoucher'][0]
    ): void
    {
        $this->deleteVoucherWithHttpInfo($code, $force, $contentType);
    }

    /**
     * Operation deleteVoucherWithHttpInfo
     *
     * Delete Voucher
     *
     * @param  string $code A unique **code** that identifies the voucher. (required)
     * @param  bool|null $force If this flag is set to true, the voucher will be removed permanently. If it is set to false or not set at all, the voucher will be moved to the bin. Going forward, the user will be able to create another voucher with exactly the same code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVoucher'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteVoucherWithHttpInfo(
        string $code,
        ?bool $force = null,
        string $contentType = self::contentTypes['deleteVoucher'][0]
    ): array
    {
        $request = $this->deleteVoucherRequest($code, $force, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteVoucherAsync
     *
     * Delete Voucher
     *
     * @param  string $code A unique **code** that identifies the voucher. (required)
     * @param  bool|null $force If this flag is set to true, the voucher will be removed permanently. If it is set to false or not set at all, the voucher will be moved to the bin. Going forward, the user will be able to create another voucher with exactly the same code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVoucher'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteVoucherAsync(
        string $code,
        ?bool $force = null,
        string $contentType = self::contentTypes['deleteVoucher'][0]
    ): PromiseInterface
    {
        return $this->deleteVoucherAsyncWithHttpInfo($code, $force, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteVoucherAsyncWithHttpInfo
     *
     * Delete Voucher
     *
     * @param  string $code A unique **code** that identifies the voucher. (required)
     * @param  bool|null $force If this flag is set to true, the voucher will be removed permanently. If it is set to false or not set at all, the voucher will be moved to the bin. Going forward, the user will be able to create another voucher with exactly the same code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVoucher'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteVoucherAsyncWithHttpInfo(
        $code,
        $force = null,
        string $contentType = self::contentTypes['deleteVoucher'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteVoucherRequest($code, $force, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteVoucher'
     *
     * @param  string $code A unique **code** that identifies the voucher. (required)
     * @param  bool|null $force If this flag is set to true, the voucher will be removed permanently. If it is set to false or not set at all, the voucher will be moved to the bin. Going forward, the user will be able to create another voucher with exactly the same code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteVoucher'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteVoucherRequest(
        $code,
        $force = null,
        string $contentType = self::contentTypes['deleteVoucher'][0]
    ): Request
    {

        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $code when calling deleteVoucher'
            );
        }



        $resourcePath = '/v1/vouchers/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $force,
            'force', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation disableVoucher
     *
     * Disable Voucher
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableVoucher'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\VouchersDisableResponseBody
     */
    public function disableVoucher(
        string $code,
        string $contentType = self::contentTypes['disableVoucher'][0]
    ): \OpenAPI\Client\Model\VouchersDisableResponseBody
    {
        list($response) = $this->disableVoucherWithHttpInfo($code, $contentType);
        return $response;
    }

    /**
     * Operation disableVoucherWithHttpInfo
     *
     * Disable Voucher
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableVoucher'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VouchersDisableResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function disableVoucherWithHttpInfo(
        string $code,
        string $contentType = self::contentTypes['disableVoucher'][0]
    ): array
    {
        $request = $this->disableVoucherRequest($code, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\OpenAPI\Client\Model\VouchersDisableResponseBody', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VouchersDisableResponseBody' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VouchersDisableResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VouchersDisableResponseBody';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VouchersDisableResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation disableVoucherAsync
     *
     * Disable Voucher
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableVoucher'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function disableVoucherAsync(
        string $code,
        string $contentType = self::contentTypes['disableVoucher'][0]
    ): PromiseInterface
    {
        return $this->disableVoucherAsyncWithHttpInfo($code, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation disableVoucherAsyncWithHttpInfo
     *
     * Disable Voucher
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableVoucher'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function disableVoucherAsyncWithHttpInfo(
        $code,
        string $contentType = self::contentTypes['disableVoucher'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\VouchersDisableResponseBody';
        $request = $this->disableVoucherRequest($code, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'disableVoucher'
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableVoucher'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function disableVoucherRequest(
        $code,
        string $contentType = self::contentTypes['disableVoucher'][0]
    ): Request
    {

        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $code when calling disableVoucher'
            );
        }


        $resourcePath = '/v1/vouchers/{code}/disable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enableVoucher
     *
     * Enable Voucher
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableVoucher'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\VouchersEnableResponseBody
     */
    public function enableVoucher(
        string $code,
        string $contentType = self::contentTypes['enableVoucher'][0]
    ): \OpenAPI\Client\Model\VouchersEnableResponseBody
    {
        list($response) = $this->enableVoucherWithHttpInfo($code, $contentType);
        return $response;
    }

    /**
     * Operation enableVoucherWithHttpInfo
     *
     * Enable Voucher
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableVoucher'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VouchersEnableResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function enableVoucherWithHttpInfo(
        string $code,
        string $contentType = self::contentTypes['enableVoucher'][0]
    ): array
    {
        $request = $this->enableVoucherRequest($code, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\OpenAPI\Client\Model\VouchersEnableResponseBody', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VouchersEnableResponseBody' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VouchersEnableResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VouchersEnableResponseBody';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VouchersEnableResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enableVoucherAsync
     *
     * Enable Voucher
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableVoucher'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function enableVoucherAsync(
        string $code,
        string $contentType = self::contentTypes['enableVoucher'][0]
    ): PromiseInterface
    {
        return $this->enableVoucherAsyncWithHttpInfo($code, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enableVoucherAsyncWithHttpInfo
     *
     * Enable Voucher
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableVoucher'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function enableVoucherAsyncWithHttpInfo(
        $code,
        string $contentType = self::contentTypes['enableVoucher'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\VouchersEnableResponseBody';
        $request = $this->enableVoucherRequest($code, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enableVoucher'
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableVoucher'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enableVoucherRequest(
        $code,
        string $contentType = self::contentTypes['enableVoucher'][0]
    ): Request
    {

        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $code when calling enableVoucher'
            );
        }


        $resourcePath = '/v1/vouchers/{code}/enable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation exportVoucherTransactions
     *
     * Export Voucher Transactions
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  \OpenAPI\Client\Model\VouchersTransactionsExportCreateRequestBody|null $vouchers_transactions_export_create_request_body Specify the parameters for the transaction export. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['exportVoucherTransactions'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\VouchersTransactionsExportCreateResponseBody
     */
    public function exportVoucherTransactions(
        string $code,
        ?\OpenAPI\Client\Model\VouchersTransactionsExportCreateRequestBody $vouchers_transactions_export_create_request_body = null,
        string $contentType = self::contentTypes['exportVoucherTransactions'][0]
    ): \OpenAPI\Client\Model\VouchersTransactionsExportCreateResponseBody
    {
        list($response) = $this->exportVoucherTransactionsWithHttpInfo($code, $vouchers_transactions_export_create_request_body, $contentType);
        return $response;
    }

    /**
     * Operation exportVoucherTransactionsWithHttpInfo
     *
     * Export Voucher Transactions
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  \OpenAPI\Client\Model\VouchersTransactionsExportCreateRequestBody|null $vouchers_transactions_export_create_request_body Specify the parameters for the transaction export. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['exportVoucherTransactions'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VouchersTransactionsExportCreateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function exportVoucherTransactionsWithHttpInfo(
        string $code,
        ?\OpenAPI\Client\Model\VouchersTransactionsExportCreateRequestBody $vouchers_transactions_export_create_request_body = null,
        string $contentType = self::contentTypes['exportVoucherTransactions'][0]
    ): array
    {
        $request = $this->exportVoucherTransactionsRequest($code, $vouchers_transactions_export_create_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\OpenAPI\Client\Model\VouchersTransactionsExportCreateResponseBody', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VouchersTransactionsExportCreateResponseBody' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VouchersTransactionsExportCreateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VouchersTransactionsExportCreateResponseBody';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VouchersTransactionsExportCreateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation exportVoucherTransactionsAsync
     *
     * Export Voucher Transactions
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  \OpenAPI\Client\Model\VouchersTransactionsExportCreateRequestBody|null $vouchers_transactions_export_create_request_body Specify the parameters for the transaction export. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['exportVoucherTransactions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function exportVoucherTransactionsAsync(
        string $code,
        ?\OpenAPI\Client\Model\VouchersTransactionsExportCreateRequestBody $vouchers_transactions_export_create_request_body = null,
        string $contentType = self::contentTypes['exportVoucherTransactions'][0]
    ): PromiseInterface
    {
        return $this->exportVoucherTransactionsAsyncWithHttpInfo($code, $vouchers_transactions_export_create_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation exportVoucherTransactionsAsyncWithHttpInfo
     *
     * Export Voucher Transactions
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  \OpenAPI\Client\Model\VouchersTransactionsExportCreateRequestBody|null $vouchers_transactions_export_create_request_body Specify the parameters for the transaction export. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['exportVoucherTransactions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function exportVoucherTransactionsAsyncWithHttpInfo(
        $code,
        $vouchers_transactions_export_create_request_body = null,
        string $contentType = self::contentTypes['exportVoucherTransactions'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\VouchersTransactionsExportCreateResponseBody';
        $request = $this->exportVoucherTransactionsRequest($code, $vouchers_transactions_export_create_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'exportVoucherTransactions'
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  \OpenAPI\Client\Model\VouchersTransactionsExportCreateRequestBody|null $vouchers_transactions_export_create_request_body Specify the parameters for the transaction export. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['exportVoucherTransactions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function exportVoucherTransactionsRequest(
        $code,
        $vouchers_transactions_export_create_request_body = null,
        string $contentType = self::contentTypes['exportVoucherTransactions'][0]
    ): Request
    {

        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $code when calling exportVoucherTransactions'
            );
        }



        $resourcePath = '/v1/vouchers/{code}/transactions/export';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vouchers_transactions_export_create_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vouchers_transactions_export_create_request_body));
            } else {
                $httpBody = $vouchers_transactions_export_create_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation generateRandomCode
     *
     * Generate Random Code
     *
     * @param  object|null $body Specify the details of the voucher that you would like to create. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateRandomCode'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\VouchersCreateResponseBody
     */
    public function generateRandomCode(
        ?array $body = null,
        string $contentType = self::contentTypes['generateRandomCode'][0]
    ): \OpenAPI\Client\Model\VouchersCreateResponseBody
    {
        list($response) = $this->generateRandomCodeWithHttpInfo($body, $contentType);
        return $response;
    }

    /**
     * Operation generateRandomCodeWithHttpInfo
     *
     * Generate Random Code
     *
     * @param  object|null $body Specify the details of the voucher that you would like to create. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateRandomCode'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VouchersCreateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function generateRandomCodeWithHttpInfo(
        ?array $body = null,
        string $contentType = self::contentTypes['generateRandomCode'][0]
    ): array
    {
        $request = $this->generateRandomCodeRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\OpenAPI\Client\Model\VouchersCreateResponseBody', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VouchersCreateResponseBody' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VouchersCreateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VouchersCreateResponseBody';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VouchersCreateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation generateRandomCodeAsync
     *
     * Generate Random Code
     *
     * @param  object|null $body Specify the details of the voucher that you would like to create. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateRandomCode'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function generateRandomCodeAsync(
        ?array $body = null,
        string $contentType = self::contentTypes['generateRandomCode'][0]
    ): PromiseInterface
    {
        return $this->generateRandomCodeAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation generateRandomCodeAsyncWithHttpInfo
     *
     * Generate Random Code
     *
     * @param  object|null $body Specify the details of the voucher that you would like to create. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateRandomCode'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function generateRandomCodeAsyncWithHttpInfo(
        $body = null,
        string $contentType = self::contentTypes['generateRandomCode'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\VouchersCreateResponseBody';
        $request = $this->generateRandomCodeRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'generateRandomCode'
     *
     * @param  object|null $body Specify the details of the voucher that you would like to create. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateRandomCode'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function generateRandomCodeRequest(
        $body = null,
        string $contentType = self::contentTypes['generateRandomCode'][0]
    ): Request
    {



        $resourcePath = '/v1/vouchers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVoucher
     *
     * Get Voucher
     *
     * @param  string $code A unique **code** that identifies the voucher. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVoucher'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\VouchersGetResponseBody
     */
    public function getVoucher(
        string $code,
        string $contentType = self::contentTypes['getVoucher'][0]
    ): \OpenAPI\Client\Model\VouchersGetResponseBody
    {
        list($response) = $this->getVoucherWithHttpInfo($code, $contentType);
        return $response;
    }

    /**
     * Operation getVoucherWithHttpInfo
     *
     * Get Voucher
     *
     * @param  string $code A unique **code** that identifies the voucher. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVoucher'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VouchersGetResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVoucherWithHttpInfo(
        string $code,
        string $contentType = self::contentTypes['getVoucher'][0]
    ): array
    {
        $request = $this->getVoucherRequest($code, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\OpenAPI\Client\Model\VouchersGetResponseBody', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VouchersGetResponseBody' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VouchersGetResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VouchersGetResponseBody';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VouchersGetResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVoucherAsync
     *
     * Get Voucher
     *
     * @param  string $code A unique **code** that identifies the voucher. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVoucher'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getVoucherAsync(
        string $code,
        string $contentType = self::contentTypes['getVoucher'][0]
    ): PromiseInterface
    {
        return $this->getVoucherAsyncWithHttpInfo($code, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVoucherAsyncWithHttpInfo
     *
     * Get Voucher
     *
     * @param  string $code A unique **code** that identifies the voucher. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVoucher'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getVoucherAsyncWithHttpInfo(
        $code,
        string $contentType = self::contentTypes['getVoucher'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\VouchersGetResponseBody';
        $request = $this->getVoucherRequest($code, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVoucher'
     *
     * @param  string $code A unique **code** that identifies the voucher. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVoucher'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getVoucherRequest(
        $code,
        string $contentType = self::contentTypes['getVoucher'][0]
    ): Request
    {

        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $code when calling getVoucher'
            );
        }


        $resourcePath = '/v1/vouchers/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation importVouchersUsingCsv
     *
     * Import Vouchers using CSV
     *
     * @param  \SplFileObject|null $file File path. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importVouchersUsingCsv'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\VouchersImportCsvCreateResponseBody
     */
    public function importVouchersUsingCsv(
        ?\SplFileObject $file = null,
        string $contentType = self::contentTypes['importVouchersUsingCsv'][0]
    ): \OpenAPI\Client\Model\VouchersImportCsvCreateResponseBody
    {
        list($response) = $this->importVouchersUsingCsvWithHttpInfo($file, $contentType);
        return $response;
    }

    /**
     * Operation importVouchersUsingCsvWithHttpInfo
     *
     * Import Vouchers using CSV
     *
     * @param  \SplFileObject|null $file File path. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importVouchersUsingCsv'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VouchersImportCsvCreateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function importVouchersUsingCsvWithHttpInfo(
        ?\SplFileObject $file = null,
        string $contentType = self::contentTypes['importVouchersUsingCsv'][0]
    ): array
    {
        $request = $this->importVouchersUsingCsvRequest($file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 202:
                    if (in_array('\OpenAPI\Client\Model\VouchersImportCsvCreateResponseBody', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VouchersImportCsvCreateResponseBody' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VouchersImportCsvCreateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VouchersImportCsvCreateResponseBody';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VouchersImportCsvCreateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation importVouchersUsingCsvAsync
     *
     * Import Vouchers using CSV
     *
     * @param  \SplFileObject|null $file File path. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importVouchersUsingCsv'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function importVouchersUsingCsvAsync(
        ?\SplFileObject $file = null,
        string $contentType = self::contentTypes['importVouchersUsingCsv'][0]
    ): PromiseInterface
    {
        return $this->importVouchersUsingCsvAsyncWithHttpInfo($file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importVouchersUsingCsvAsyncWithHttpInfo
     *
     * Import Vouchers using CSV
     *
     * @param  \SplFileObject|null $file File path. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importVouchersUsingCsv'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function importVouchersUsingCsvAsyncWithHttpInfo(
        $file = null,
        string $contentType = self::contentTypes['importVouchersUsingCsv'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\VouchersImportCsvCreateResponseBody';
        $request = $this->importVouchersUsingCsvRequest($file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importVouchersUsingCsv'
     *
     * @param  \SplFileObject|null $file File path. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importVouchersUsingCsv'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function importVouchersUsingCsvRequest(
        $file = null,
        string $contentType = self::contentTypes['importVouchersUsingCsv'][0]
    ): Request
    {



        $resourcePath = '/v1/vouchers/importCSV';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = [];
            $paramFiles = is_array($file) ? $file : [$file];
            foreach ($paramFiles as $paramFile) {
                $formParams['file'][] = $paramFile instanceof \Psr\Http\Message\StreamInterface
                    ? $paramFile
                    : \GuzzleHttp\Psr7\Utils::tryFopen(
                        ObjectSerializer::toFormValue($paramFile),
                        'rb'
                    );
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listVoucherTransactions
     *
     * List Voucher Transactions
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  int|null $limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param  int|null $page Which page of results to return. The lowest value is 1. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVoucherTransactions'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\VouchersTransactionsListResponseBody
     */
    public function listVoucherTransactions(
        string $code,
        ?int $limit = null,
        ?int $page = null,
        string $contentType = self::contentTypes['listVoucherTransactions'][0]
    ): \OpenAPI\Client\Model\VouchersTransactionsListResponseBody
    {
        list($response) = $this->listVoucherTransactionsWithHttpInfo($code, $limit, $page, $contentType);
        return $response;
    }

    /**
     * Operation listVoucherTransactionsWithHttpInfo
     *
     * List Voucher Transactions
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  int|null $limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param  int|null $page Which page of results to return. The lowest value is 1. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVoucherTransactions'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VouchersTransactionsListResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listVoucherTransactionsWithHttpInfo(
        string $code,
        ?int $limit = null,
        ?int $page = null,
        string $contentType = self::contentTypes['listVoucherTransactions'][0]
    ): array
    {
        $request = $this->listVoucherTransactionsRequest($code, $limit, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\OpenAPI\Client\Model\VouchersTransactionsListResponseBody', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VouchersTransactionsListResponseBody' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VouchersTransactionsListResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VouchersTransactionsListResponseBody';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VouchersTransactionsListResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listVoucherTransactionsAsync
     *
     * List Voucher Transactions
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  int|null $limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param  int|null $page Which page of results to return. The lowest value is 1. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVoucherTransactions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listVoucherTransactionsAsync(
        string $code,
        ?int $limit = null,
        ?int $page = null,
        string $contentType = self::contentTypes['listVoucherTransactions'][0]
    ): PromiseInterface
    {
        return $this->listVoucherTransactionsAsyncWithHttpInfo($code, $limit, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listVoucherTransactionsAsyncWithHttpInfo
     *
     * List Voucher Transactions
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  int|null $limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param  int|null $page Which page of results to return. The lowest value is 1. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVoucherTransactions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listVoucherTransactionsAsyncWithHttpInfo(
        $code,
        $limit = null,
        $page = null,
        string $contentType = self::contentTypes['listVoucherTransactions'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\VouchersTransactionsListResponseBody';
        $request = $this->listVoucherTransactionsRequest($code, $limit, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listVoucherTransactions'
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  int|null $limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param  int|null $page Which page of results to return. The lowest value is 1. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVoucherTransactions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listVoucherTransactionsRequest(
        $code,
        $limit = null,
        $page = null,
        string $contentType = self::contentTypes['listVoucherTransactions'][0]
    ): Request
    {

        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $code when calling listVoucherTransactions'
            );
        }

        if ($limit !== null && $limit > 100) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling VouchersApi.listVoucherTransactions, must be smaller than or equal to 100.');
        }
        if ($limit !== null && $limit < 1) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling VouchersApi.listVoucherTransactions, must be bigger than or equal to 1.');
        }
        
        if ($page !== null && $page > 100) {
            throw new InvalidArgumentException('invalid value for "$page" when calling VouchersApi.listVoucherTransactions, must be smaller than or equal to 100.');
        }
        if ($page !== null && $page < 1) {
            throw new InvalidArgumentException('invalid value for "$page" when calling VouchersApi.listVoucherTransactions, must be bigger than or equal to 1.');
        }
        

        $resourcePath = '/v1/vouchers/{code}/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listVouchers
     *
     * List Vouchers
     *
     * @param  int|null $limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param  int|null $page Which page of results to return. The lowest value is 1. (optional)
     * @param  string|null $category Limit search results to vouchers within the specified category. (optional)
     * @param  string|null $campaign_id Limit search results to vouchers within the specified campaign (optional)
     * @param  string|null $customer A tracking identifier of a customer who is the holder of the vouchers. It can be an id generated by Voucherify or the source_id. Remember to use the proper URL escape codes if the source_id contains special characters. (optional)
     * @param  string|null $campaign A unique campaign name, identifies the parent campaign. (optional)
     * @param  ParameterCreatedBeforeAfter|null $created_at A filter on the list based on the object created_at field. The value is a dictionary with the following options: before, after. A date value must be presented in ISO 8601 format (2016-11-16T14:14:31Z or 2016-11-16). An example: [created_at][before] 2017-09-08T13:52:18.227Z (optional)
     * @param  ParameterUpdatedBeforeAfter|null $updated_at A filter on the list based on the object updated_at field. The value is a dictionary with the following options: before, after. A date value must be presented in ISO 8601 format (2016-11-16T14:14:31Z or 2016-11-16). An example: [updated_at][before] 2017-09-08T13:52:18.227Z (optional)
     * @param  ParameterOrderVouchers|null $order Sorts the results using one of the filtering options, where the dash - preceding a sorting option means sorting in a descending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVouchers'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\VouchersListResponseBody
     */
    public function listVouchers(
        ?int $limit = null,
        ?int $page = null,
        ?string $category = null,
        ?string $campaign_id = null,
        ?string $customer = null,
        ?string $campaign = null,
        ?ParameterCreatedBeforeAfter $created_at = null,
        ?ParameterUpdatedBeforeAfter $updated_at = null,
        ?ParameterOrderVouchers $order = null,
        string $contentType = self::contentTypes['listVouchers'][0]
    ): \OpenAPI\Client\Model\VouchersListResponseBody
    {
        list($response) = $this->listVouchersWithHttpInfo($limit, $page, $category, $campaign_id, $customer, $campaign, $created_at, $updated_at, $order, $contentType);
        return $response;
    }

    /**
     * Operation listVouchersWithHttpInfo
     *
     * List Vouchers
     *
     * @param  int|null $limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param  int|null $page Which page of results to return. The lowest value is 1. (optional)
     * @param  string|null $category Limit search results to vouchers within the specified category. (optional)
     * @param  string|null $campaign_id Limit search results to vouchers within the specified campaign (optional)
     * @param  string|null $customer A tracking identifier of a customer who is the holder of the vouchers. It can be an id generated by Voucherify or the source_id. Remember to use the proper URL escape codes if the source_id contains special characters. (optional)
     * @param  string|null $campaign A unique campaign name, identifies the parent campaign. (optional)
     * @param  ParameterCreatedBeforeAfter|null $created_at A filter on the list based on the object created_at field. The value is a dictionary with the following options: before, after. A date value must be presented in ISO 8601 format (2016-11-16T14:14:31Z or 2016-11-16). An example: [created_at][before] 2017-09-08T13:52:18.227Z (optional)
     * @param  ParameterUpdatedBeforeAfter|null $updated_at A filter on the list based on the object updated_at field. The value is a dictionary with the following options: before, after. A date value must be presented in ISO 8601 format (2016-11-16T14:14:31Z or 2016-11-16). An example: [updated_at][before] 2017-09-08T13:52:18.227Z (optional)
     * @param  ParameterOrderVouchers|null $order Sorts the results using one of the filtering options, where the dash - preceding a sorting option means sorting in a descending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVouchers'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VouchersListResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function listVouchersWithHttpInfo(
        ?int $limit = null,
        ?int $page = null,
        ?string $category = null,
        ?string $campaign_id = null,
        ?string $customer = null,
        ?string $campaign = null,
        ?ParameterCreatedBeforeAfter $created_at = null,
        ?ParameterUpdatedBeforeAfter $updated_at = null,
        ?ParameterOrderVouchers $order = null,
        string $contentType = self::contentTypes['listVouchers'][0]
    ): array
    {
        $request = $this->listVouchersRequest($limit, $page, $category, $campaign_id, $customer, $campaign, $created_at, $updated_at, $order, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\OpenAPI\Client\Model\VouchersListResponseBody', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VouchersListResponseBody' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VouchersListResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VouchersListResponseBody';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VouchersListResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listVouchersAsync
     *
     * List Vouchers
     *
     * @param  int|null $limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param  int|null $page Which page of results to return. The lowest value is 1. (optional)
     * @param  string|null $category Limit search results to vouchers within the specified category. (optional)
     * @param  string|null $campaign_id Limit search results to vouchers within the specified campaign (optional)
     * @param  string|null $customer A tracking identifier of a customer who is the holder of the vouchers. It can be an id generated by Voucherify or the source_id. Remember to use the proper URL escape codes if the source_id contains special characters. (optional)
     * @param  string|null $campaign A unique campaign name, identifies the parent campaign. (optional)
     * @param  ParameterCreatedBeforeAfter|null $created_at A filter on the list based on the object created_at field. The value is a dictionary with the following options: before, after. A date value must be presented in ISO 8601 format (2016-11-16T14:14:31Z or 2016-11-16). An example: [created_at][before] 2017-09-08T13:52:18.227Z (optional)
     * @param  ParameterUpdatedBeforeAfter|null $updated_at A filter on the list based on the object updated_at field. The value is a dictionary with the following options: before, after. A date value must be presented in ISO 8601 format (2016-11-16T14:14:31Z or 2016-11-16). An example: [updated_at][before] 2017-09-08T13:52:18.227Z (optional)
     * @param  ParameterOrderVouchers|null $order Sorts the results using one of the filtering options, where the dash - preceding a sorting option means sorting in a descending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVouchers'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listVouchersAsync(
        ?int $limit = null,
        ?int $page = null,
        ?string $category = null,
        ?string $campaign_id = null,
        ?string $customer = null,
        ?string $campaign = null,
        ?ParameterCreatedBeforeAfter $created_at = null,
        ?ParameterUpdatedBeforeAfter $updated_at = null,
        ?ParameterOrderVouchers $order = null,
        string $contentType = self::contentTypes['listVouchers'][0]
    ): PromiseInterface
    {
        return $this->listVouchersAsyncWithHttpInfo($limit, $page, $category, $campaign_id, $customer, $campaign, $created_at, $updated_at, $order, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listVouchersAsyncWithHttpInfo
     *
     * List Vouchers
     *
     * @param  int|null $limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param  int|null $page Which page of results to return. The lowest value is 1. (optional)
     * @param  string|null $category Limit search results to vouchers within the specified category. (optional)
     * @param  string|null $campaign_id Limit search results to vouchers within the specified campaign (optional)
     * @param  string|null $customer A tracking identifier of a customer who is the holder of the vouchers. It can be an id generated by Voucherify or the source_id. Remember to use the proper URL escape codes if the source_id contains special characters. (optional)
     * @param  string|null $campaign A unique campaign name, identifies the parent campaign. (optional)
     * @param  ParameterCreatedBeforeAfter|null $created_at A filter on the list based on the object created_at field. The value is a dictionary with the following options: before, after. A date value must be presented in ISO 8601 format (2016-11-16T14:14:31Z or 2016-11-16). An example: [created_at][before] 2017-09-08T13:52:18.227Z (optional)
     * @param  ParameterUpdatedBeforeAfter|null $updated_at A filter on the list based on the object updated_at field. The value is a dictionary with the following options: before, after. A date value must be presented in ISO 8601 format (2016-11-16T14:14:31Z or 2016-11-16). An example: [updated_at][before] 2017-09-08T13:52:18.227Z (optional)
     * @param  ParameterOrderVouchers|null $order Sorts the results using one of the filtering options, where the dash - preceding a sorting option means sorting in a descending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVouchers'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listVouchersAsyncWithHttpInfo(
        $limit = null,
        $page = null,
        $category = null,
        $campaign_id = null,
        $customer = null,
        $campaign = null,
        $created_at = null,
        $updated_at = null,
        $order = null,
        string $contentType = self::contentTypes['listVouchers'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\VouchersListResponseBody';
        $request = $this->listVouchersRequest($limit, $page, $category, $campaign_id, $customer, $campaign, $created_at, $updated_at, $order, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listVouchers'
     *
     * @param  int|null $limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param  int|null $page Which page of results to return. The lowest value is 1. (optional)
     * @param  string|null $category Limit search results to vouchers within the specified category. (optional)
     * @param  string|null $campaign_id Limit search results to vouchers within the specified campaign (optional)
     * @param  string|null $customer A tracking identifier of a customer who is the holder of the vouchers. It can be an id generated by Voucherify or the source_id. Remember to use the proper URL escape codes if the source_id contains special characters. (optional)
     * @param  string|null $campaign A unique campaign name, identifies the parent campaign. (optional)
     * @param  ParameterCreatedBeforeAfter|null $created_at A filter on the list based on the object created_at field. The value is a dictionary with the following options: before, after. A date value must be presented in ISO 8601 format (2016-11-16T14:14:31Z or 2016-11-16). An example: [created_at][before] 2017-09-08T13:52:18.227Z (optional)
     * @param  ParameterUpdatedBeforeAfter|null $updated_at A filter on the list based on the object updated_at field. The value is a dictionary with the following options: before, after. A date value must be presented in ISO 8601 format (2016-11-16T14:14:31Z or 2016-11-16). An example: [updated_at][before] 2017-09-08T13:52:18.227Z (optional)
     * @param  ParameterOrderVouchers|null $order Sorts the results using one of the filtering options, where the dash - preceding a sorting option means sorting in a descending order. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVouchers'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listVouchersRequest(
        $limit = null,
        $page = null,
        $category = null,
        $campaign_id = null,
        $customer = null,
        $campaign = null,
        $created_at = null,
        $updated_at = null,
        $order = null,
        string $contentType = self::contentTypes['listVouchers'][0]
    ): Request
    {

        if ($limit !== null && $limit > 100) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling VouchersApi.listVouchers, must be smaller than or equal to 100.');
        }
        if ($limit !== null && $limit < 1) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling VouchersApi.listVouchers, must be bigger than or equal to 1.');
        }
        
        if ($page !== null && $page > 100) {
            throw new InvalidArgumentException('invalid value for "$page" when calling VouchersApi.listVouchers, must be smaller than or equal to 100.');
        }
        if ($page !== null && $page < 1) {
            throw new InvalidArgumentException('invalid value for "$page" when calling VouchersApi.listVouchers, must be bigger than or equal to 1.');
        }
        








        $resourcePath = '/v1/vouchers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $campaign_id,
            'campaign_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $customer,
            'customer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $campaign,
            'campaign', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at,
            'created_at', // param base name
            'object', // openApiType
            'deepObject', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updated_at', // param base name
            'object', // openApiType
            'deepObject', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'ParameterOrderVouchers', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releaseValidationSession
     *
     * Release Validation Session
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify. (required)
     * @param  string $session_key A unique session identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['releaseValidationSession'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function releaseValidationSession(
        string $code,
        string $session_key,
        string $contentType = self::contentTypes['releaseValidationSession'][0]
    ): void
    {
        $this->releaseValidationSessionWithHttpInfo($code, $session_key, $contentType);
    }

    /**
     * Operation releaseValidationSessionWithHttpInfo
     *
     * Release Validation Session
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify. (required)
     * @param  string $session_key A unique session identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['releaseValidationSession'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function releaseValidationSessionWithHttpInfo(
        string $code,
        string $session_key,
        string $contentType = self::contentTypes['releaseValidationSession'][0]
    ): array
    {
        $request = $this->releaseValidationSessionRequest($code, $session_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation releaseValidationSessionAsync
     *
     * Release Validation Session
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify. (required)
     * @param  string $session_key A unique session identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['releaseValidationSession'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function releaseValidationSessionAsync(
        string $code,
        string $session_key,
        string $contentType = self::contentTypes['releaseValidationSession'][0]
    ): PromiseInterface
    {
        return $this->releaseValidationSessionAsyncWithHttpInfo($code, $session_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releaseValidationSessionAsyncWithHttpInfo
     *
     * Release Validation Session
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify. (required)
     * @param  string $session_key A unique session identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['releaseValidationSession'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function releaseValidationSessionAsyncWithHttpInfo(
        $code,
        $session_key,
        string $contentType = self::contentTypes['releaseValidationSession'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->releaseValidationSessionRequest($code, $session_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releaseValidationSession'
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify. (required)
     * @param  string $session_key A unique session identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['releaseValidationSession'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function releaseValidationSessionRequest(
        $code,
        $session_key,
        string $contentType = self::contentTypes['releaseValidationSession'][0]
    ): Request
    {

        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $code when calling releaseValidationSession'
            );
        }

        // verify the required parameter 'session_key' is set
        if ($session_key === null || (is_array($session_key) && count($session_key) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $session_key when calling releaseValidationSession'
            );
        }


        $resourcePath = '/v1/vouchers/{code}/sessions/{sessionKey}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }
        // path params
        if ($session_key !== null) {
            $resourcePath = str_replace(
                '{' . 'sessionKey' . '}',
                ObjectSerializer::toPathValue($session_key),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateVoucher
     *
     * Update Voucher
     *
     * @param  string $code A unique **code** that identifies the voucher. (required)
     * @param  \OpenAPI\Client\Model\VouchersUpdateRequestBody $vouchers_update_request_body Specify the parameters to be updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVoucher'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\VouchersUpdateResponseBody
     */
    public function updateVoucher(
        string $code,
        \OpenAPI\Client\Model\VouchersUpdateRequestBody $vouchers_update_request_body,
        string $contentType = self::contentTypes['updateVoucher'][0]
    ): \OpenAPI\Client\Model\VouchersUpdateResponseBody
    {
        list($response) = $this->updateVoucherWithHttpInfo($code, $vouchers_update_request_body, $contentType);
        return $response;
    }

    /**
     * Operation updateVoucherWithHttpInfo
     *
     * Update Voucher
     *
     * @param  string $code A unique **code** that identifies the voucher. (required)
     * @param  \OpenAPI\Client\Model\VouchersUpdateRequestBody $vouchers_update_request_body Specify the parameters to be updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVoucher'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VouchersUpdateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateVoucherWithHttpInfo(
        string $code,
        \OpenAPI\Client\Model\VouchersUpdateRequestBody $vouchers_update_request_body,
        string $contentType = self::contentTypes['updateVoucher'][0]
    ): array
    {
        $request = $this->updateVoucherRequest($code, $vouchers_update_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\OpenAPI\Client\Model\VouchersUpdateResponseBody', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VouchersUpdateResponseBody' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VouchersUpdateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VouchersUpdateResponseBody';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VouchersUpdateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateVoucherAsync
     *
     * Update Voucher
     *
     * @param  string $code A unique **code** that identifies the voucher. (required)
     * @param  \OpenAPI\Client\Model\VouchersUpdateRequestBody $vouchers_update_request_body Specify the parameters to be updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVoucher'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateVoucherAsync(
        string $code,
        \OpenAPI\Client\Model\VouchersUpdateRequestBody $vouchers_update_request_body,
        string $contentType = self::contentTypes['updateVoucher'][0]
    ): PromiseInterface
    {
        return $this->updateVoucherAsyncWithHttpInfo($code, $vouchers_update_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateVoucherAsyncWithHttpInfo
     *
     * Update Voucher
     *
     * @param  string $code A unique **code** that identifies the voucher. (required)
     * @param  \OpenAPI\Client\Model\VouchersUpdateRequestBody $vouchers_update_request_body Specify the parameters to be updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVoucher'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateVoucherAsyncWithHttpInfo(
        $code,
        $vouchers_update_request_body,
        string $contentType = self::contentTypes['updateVoucher'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\VouchersUpdateResponseBody';
        $request = $this->updateVoucherRequest($code, $vouchers_update_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateVoucher'
     *
     * @param  string $code A unique **code** that identifies the voucher. (required)
     * @param  \OpenAPI\Client\Model\VouchersUpdateRequestBody $vouchers_update_request_body Specify the parameters to be updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVoucher'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateVoucherRequest(
        $code,
        $vouchers_update_request_body,
        string $contentType = self::contentTypes['updateVoucher'][0]
    ): Request
    {

        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $code when calling updateVoucher'
            );
        }

        // verify the required parameter 'vouchers_update_request_body' is set
        if ($vouchers_update_request_body === null || (is_array($vouchers_update_request_body) && count($vouchers_update_request_body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $vouchers_update_request_body when calling updateVoucher'
            );
        }


        $resourcePath = '/v1/vouchers/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vouchers_update_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vouchers_update_request_body));
            } else {
                $httpBody = $vouchers_update_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateVoucherBalance
     *
     * Add or Remove Voucher Balance
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  \OpenAPI\Client\Model\VouchersBalanceUpdateRequestBody $vouchers_balance_update_request_body Provide the amount to be added to/subtracted from the voucher. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVoucherBalance'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\VouchersBalanceUpdateResponseBody
     */
    public function updateVoucherBalance(
        string $code,
        \OpenAPI\Client\Model\VouchersBalanceUpdateRequestBody $vouchers_balance_update_request_body,
        string $contentType = self::contentTypes['updateVoucherBalance'][0]
    ): \OpenAPI\Client\Model\VouchersBalanceUpdateResponseBody
    {
        list($response) = $this->updateVoucherBalanceWithHttpInfo($code, $vouchers_balance_update_request_body, $contentType);
        return $response;
    }

    /**
     * Operation updateVoucherBalanceWithHttpInfo
     *
     * Add or Remove Voucher Balance
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  \OpenAPI\Client\Model\VouchersBalanceUpdateRequestBody $vouchers_balance_update_request_body Provide the amount to be added to/subtracted from the voucher. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVoucherBalance'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VouchersBalanceUpdateResponseBody, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateVoucherBalanceWithHttpInfo(
        string $code,
        \OpenAPI\Client\Model\VouchersBalanceUpdateRequestBody $vouchers_balance_update_request_body,
        string $contentType = self::contentTypes['updateVoucherBalance'][0]
    ): array
    {
        $request = $this->updateVoucherBalanceRequest($code, $vouchers_balance_update_request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\OpenAPI\Client\Model\VouchersBalanceUpdateResponseBody', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VouchersBalanceUpdateResponseBody' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VouchersBalanceUpdateResponseBody', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\VouchersBalanceUpdateResponseBody';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VouchersBalanceUpdateResponseBody',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateVoucherBalanceAsync
     *
     * Add or Remove Voucher Balance
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  \OpenAPI\Client\Model\VouchersBalanceUpdateRequestBody $vouchers_balance_update_request_body Provide the amount to be added to/subtracted from the voucher. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVoucherBalance'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateVoucherBalanceAsync(
        string $code,
        \OpenAPI\Client\Model\VouchersBalanceUpdateRequestBody $vouchers_balance_update_request_body,
        string $contentType = self::contentTypes['updateVoucherBalance'][0]
    ): PromiseInterface
    {
        return $this->updateVoucherBalanceAsyncWithHttpInfo($code, $vouchers_balance_update_request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateVoucherBalanceAsyncWithHttpInfo
     *
     * Add or Remove Voucher Balance
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  \OpenAPI\Client\Model\VouchersBalanceUpdateRequestBody $vouchers_balance_update_request_body Provide the amount to be added to/subtracted from the voucher. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVoucherBalance'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateVoucherBalanceAsyncWithHttpInfo(
        $code,
        $vouchers_balance_update_request_body,
        string $contentType = self::contentTypes['updateVoucherBalance'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\VouchersBalanceUpdateResponseBody';
        $request = $this->updateVoucherBalanceRequest($code, $vouchers_balance_update_request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateVoucherBalance'
     *
     * @param  string $code A **code** that identifies the voucher or a unique voucher ID assigned by Voucherify, i.e. v_TzD19aeNiqGc9LWciMWknyEZT8IW7u4u. (required)
     * @param  \OpenAPI\Client\Model\VouchersBalanceUpdateRequestBody $vouchers_balance_update_request_body Provide the amount to be added to/subtracted from the voucher. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVoucherBalance'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateVoucherBalanceRequest(
        $code,
        $vouchers_balance_update_request_body,
        string $contentType = self::contentTypes['updateVoucherBalance'][0]
    ): Request
    {

        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $code when calling updateVoucherBalance'
            );
        }

        // verify the required parameter 'vouchers_balance_update_request_body' is set
        if ($vouchers_balance_update_request_body === null || (is_array($vouchers_balance_update_request_body) && count($vouchers_balance_update_request_body) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $vouchers_balance_update_request_body when calling updateVoucherBalance'
            );
        }


        $resourcePath = '/v1/vouchers/{code}/balance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($vouchers_balance_update_request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($vouchers_balance_update_request_body));
            } else {
                $httpBody = $vouchers_balance_update_request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Id');
        if ($apiKey !== null) {
            $headers['X-App-Id'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-App-Token');
        if ($apiKey !== null) {
            $headers['X-App-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
